name: Auto build evopt (track upstream main, SemVer + lint)

on:
  schedule:
    - cron: "0 14 * * *"        # ~16:00 Europe/Berlin (UTC)
  workflow_dispatch: {}

concurrency:
  group: evopt-main-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: write               # nötig für die State-Commits

jobs:
  # -------------------------------------------------------------
  # 1) Upstream-SHA zuverlässig holen (HEAD von andig/evopt@main)
  # -------------------------------------------------------------
  prep:
    runs-on: ubuntu-latest
    outputs:
      sha: ${{ steps.get.outputs.sha }}
    steps:
      - name: Get latest upstream main commit (ls-remote)
        id: get
        run: |
          SHA="$(git ls-remote https://github.com/andig/evopt.git refs/heads/main | cut -f1)"
          if [ -z "$SHA" ]; then
            echo "Failed to fetch upstream SHA"; exit 1
          fi
          echo "sha=$SHA" >> "$GITHUB_OUTPUT"
          echo "Upstream main SHA: $SHA"

  # ------------------------------------
  # 2) Lint (nicht-blockierend) mit DL
  # ------------------------------------
  lint:
    needs: prep
    runs-on: ubuntu-latest
    steps:
      - name: Fetch upstream at exact commit
        run: |
          git clone --no-checkout https://github.com/andig/evopt.git src
          cd src
          git fetch --depth 1 origin ${{ needs.prep.outputs.sha }}
          git checkout ${{ needs.prep.outputs.sha }}
      - name: Lint Dockerfile with hadolint (non-blocking)
        uses: hadolint/hadolint-action@v3.1.0
        with:
          dockerfile: src/Dockerfile
          failure-threshold: error
          no-fail: true

  # -------------------------------------------------------------
  # 3) Build + SemVer (mit State in .state/, robust & mit Debug)
  # -------------------------------------------------------------
    build:
    needs: [prep, lint]
    if: github.event_name != 'pull_request' &&
        (github.event_name != 'push' || !contains(github.event.head_commit.message, '[skip ci]'))
    runs-on: ubuntu-latest
    steps:
      # --- A) Checkout mit kompletter History auf main
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: main

      # --- B) Lokalen main-Historystand an origin/main angleichen (hart, robust gg. Force-Push)
      - name: Align local main to origin/main
        run: |
          git fetch origin main
          git checkout -B main
          git reset --hard origin/main

      # --- C) Guard: .state darf nicht ignoriert werden (dein Original)
      - name: Ensure .state is not ignored
        run: git check-ignore -v .state || true

      # --- D) Base-Version bestimmen (dein Original)
      - name: Determine base SemVer (state or Docker Hub)
        id: basever
        run: |
          BASE="$(test -f .state/EVOPT_MAIN_VERSION && cat .state/EVOPT_MAIN_VERSION || echo '')"
          if [ -z "$BASE" ]; then
            BASE=$(curl -s 'https://hub.docker.com/v2/repositories/litithio/evopt/tags?page_size=100' \
              | jq -r '.results[].name' \
              | grep -E '^[0-9]+\.[0-9]+\.[0-9]+$' \
              | sort -t. -k1,1n -k2,2n -k3,3n | tail -n1)
          fi
          [[ "$BASE" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]] || BASE="0.1.0"
          echo "base=$BASE" >> $GITHUB_OUTPUT
          echo "Base version: $BASE"

      # --- E) Upstream-Änderung erkennen (dein Original)
      - name: Detect upstream change
        id: change
        run: |
          mkdir -p .state
          PREV_SHA="$(test -f .state/EVOPT_MAIN_LAST_SHA && cat .state/EVOPT_MAIN_LAST_SHA || echo '')"
          CUR_SHA='${{ needs.prep.outputs.sha }}'
          echo "PREV_SHA=$PREV_SHA"
          echo "CUR_SHA=$CUR_SHA"
          if [ -n "$CUR_SHA" ] && [ "$CUR_SHA" != "$PREV_SHA" ]; then
            echo "changed=true" >> $GITHUB_OUTPUT
          else
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "No upstream change -> skipping build."
          fi

      # --- F) SemVer (dein Original)
      - name: Compute next SemVer
        id: semver
        if: steps.change.outputs.changed == 'true'
        run: |
          IFS='.' read -r MA MI PA <<< "${{ steps.basever.outputs.base }}"
          NEXT="$MA.$MI.$((PA+1))"
          echo "next=$NEXT" >> $GITHUB_OUTPUT
          echo "Next version: $NEXT"

      - name: Show current & next version
        if: steps.change.outputs.changed == 'true'
        run: |
          echo "CURRENT=$(cat .state/EVOPT_MAIN_VERSION 2>/dev/null || echo '<missing>')"
          echo "NEXT=${{ steps.semver.outputs.next }}"

      # --- G) Buildx/Login nur bei Änderung (dein Original)
      - uses: docker/setup-qemu-action@v3
        if: steps.change.outputs.changed == 'true'
      - uses: docker/setup-buildx-action@v3
        if: steps.change.outputs.changed == 'true'
      - uses: docker/login-action@v3
        if: steps.change.outputs.changed == 'true'
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # --- H) Build & Push (dein Original)
      - name: Build & push multi-arch image
        if: steps.change.outputs.changed == 'true'
        uses: docker/build-push-action@v6
        with:
          context: https://github.com/andig/evopt.git#${{ needs.prep.outputs.sha }}
          platforms: linux/amd64,linux/arm64
          push: true
          tags: |
            litithio/evopt:${{ steps.semver.outputs.next }}
            litithio/evopt:latest
          labels: |
            org.opencontainers.image.version=${{ steps.semver.outputs.next }}
            org.opencontainers.image.revision=${{ needs.prep.outputs.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # --- I) State-Dateien schreiben & anzeigen (dein Original)
      - name: Record processed SHA + version (and show)
        if: steps.change.outputs.changed == 'true'
        run: |
          echo '${{ needs.prep.outputs.sha }}' > .state/EVOPT_MAIN_LAST_SHA
          echo '${{ steps.semver.outputs.next }}' > .state/EVOPT_MAIN_VERSION
          echo "Wrote LAST_SHA=$(cat .state/EVOPT_MAIN_LAST_SHA)"
          echo "Wrote VERSION=$(cat .state/EVOPT_MAIN_VERSION)"

      - name: Debug list .state content (pre-commit)
        if: steps.change.outputs.changed == 'true'
        run: |
          ls -la .state || true
          git status --porcelain .state

      # --- J) Auto-Commit gezielt auf main pushen (NEU: branch + force-with-lease)
      - name: Commit state update
        if: steps.change.outputs.changed == 'true'
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "chore(evopt main): release ${{ steps.semver.outputs.next }} for ${{ needs.prep.outputs.sha }} [skip ci]"
          file_pattern: |
            .state/EVOPT_MAIN_LAST_SHA
            .state/EVOPT_MAIN_VERSION
          branch: main
          push_options: '--force-with-lease'

      # --- K) Fallback (nur falls das Action-Plugin nichts staged) – pusht ebenfalls auf main
      - name: Fallback commit state
        if: steps.change.outputs.changed == 'true'
        run: |
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git config user.name  "github-actions[bot]"
          git add .state/EVOPT_MAIN_LAST_SHA .state/EVOPT_MAIN_VERSION
          if git diff --cached --quiet; then
            echo "No changes staged (version may be identical)."
          else
            git commit -m "chore(state): update to ${{ steps.semver.outputs.next }} [skip ci]"
            git push origin HEAD:main --force-with-lease
          fi
